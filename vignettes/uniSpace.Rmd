---
title: "Univariate species distribution models with `mapSpecies`"
author: "F. Guillaume Blanchet"
date: "March 2019"
output:
  rmarkdown::html_vignette:
    fig_caption: yes
    self_contained: true
    keep_html: yes
    keep_md: yes
vignette: |
  %\VignetteIndexEntry{Single species distribution modelling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
bibliography: biblio.bib
---

```{r, echo=FALSE, message=FALSE, results='hide', purl=FALSE}
knitr::opts_chunk$set(cache=F,fig.width=5,fig.height=5,dpi=125)
```

# Introduction

This particular vignette was written to explain how to build univariate spatially constrained species distribution models using `mapSpecies`. In essence, this vignette shows how to use the `uniSpace` function and a few helper functions to build models. 

The modelling approach implemented in the `uniSpace` function is essentially a specialized wrapper around the `INLA` R package so that it can be easier to construct spatial models using the stochastic partial differential approach (@lindgren_explicit_2011). As a note, the `uniSpace` function is flexible enough that it can be used with a range of data type assuming that the likelihoods and link functions have been implemented in INLA. The different likelihood that can be used in the `uniSpace` function, can be found by typing `INLA::inla.list.models("likelihood")` while the link functions that can be used can be found by typing `INLA::inla.list.models("link")`.

To illustrate how the models are constructed, the mite data will be used.

# Load R package for the analysis

```{r, message = FALSE, warning=FALSE}
library(mapSpecies)
```

# Data

The data used here comes from @borcard_environmental_1994. For the purpose of this illustration, substrate density and water content (the two continuous variables) have been interpolated across the sampling area with kriging while the class variables were reconstructed from Figure 1 of @borcard_environmental_1994. These data are all available in `mite.envRaster` a `RasterStack`. As for the species data, the sampled coordinates and the species abundances available in the `vegan` R package were organized in a `SpatialPointDataFrame` and are available in `mite.spdf`.

## Species data

```{r}
# Load species data
data(mite.spdf)
```

## Environmental data

```{r}
# Environmental data
data(mite.envRaster)
```

## Sampling region

For our illustration, let's also build a `SpatialPolygons` outlining the sampling area. This will become handy for a few steps when performing the analysis.

```{r}
poly <- Polygon(matrix(c(0,0,2.6,2.6,0,0,10,10,0,0), 
                       nrow = 5, ncol = 2))
spacePoly <- SpatialPolygons(list(Polygons(list(poly), ID = 1)))
```

# Estimate the probability occurrence of a single species

For the sake of this illustration, we will focus solely on the pseudospecies coded as MEGR. As such, a new `SpatialPointDataFrame` will be constructed to focus on MEGR.

The flexibility of `uniSpace`, the presence-absence as well as the abundance of the species will be considered.

```{r}
# Presence-absence of MEGR
MEGR01 <- mite.spdf[7]
MEGR01@data[,1] <- ifelse(MEGR01@data[,1] > 0, 1, 0)
```

## Building the mesh

The core of the analyses carried out in this document will be performed using the `uniSpace` function. The first step that needs to be carried out to use this function (and thus to construct a spatially constrained model) is to build a Delaunay triangulation, a mesh, that will serve as a basis to construct the spatial component of the model through an SPDE approach. 

Properly choosing the structure of the mesh is essential for the model estimation to be carried out properly. Detailed explanation on the dos and don'ts of constructing a mesh is presented in section 1.3 of the  [R-INLA tutorial on SPDE models](http://inla.r-inla-download.org/r-inla.org/tutorials/spde/html/). For a quick overview, take a look at the *mesh* vignette.

For our illustration, let's use the following mesh.

```{r}
Mesh <- inla.mesh.2d(loc.domain = MEGR01, max.edge = 0.5,
                     offset = c(0.5,0.5))
```

```{r, fig.width = 3, fig.height=3}
par(mar = c(1,1,1,1))

plot(Mesh, main = "")
points(coordinates(MEGR01), pch = 19, col = "red")

# Number of edges in the mesh
Mesh$n
```

## Organizing the explanatory variables

To build a model with `uniSpace` explanatory variables value need to be gathered for all edges of the mesh, even the ones outside the sampling region. This is important to prevent edge effect problems that may arise in model such as the one used here.

The function `explanaMesh` is design to gather this information. In addition, the resulting object includes the `Raster*` of explanatory variable(s) and the mesh.

Note that running the `explanaMesh` function may take a bit of time. Also if you run the code below in your console, warning messages will pop simply because no projections were included in either `spacePoly`, `mesh` or `mite.envRaster`. This is normal as the coordinate are at very fine scale making a projection essentially useless. 

```{r, warning = FALSE}
explana <- explanaMesh(sp = spacePoly, 
                       mesh = Mesh, 
                       X = mite.envRaster)
```

## Building the model

Now that all the pieces are constructed we can estimate the model using `uniSpace`. 

Let's build a logistic for the presence-absence. Note that, we included the argument `control.compute`, an argument from INLA, to compute a Watanabe-Akaike information criterion (WAIC). Usually, the WAIC is ushed to compare different models, however here it was included simply to show that `uniSpace` will pass additional arguments to the `inla` function,. 

What is important to be aware at this point is that `uniSpace` is essentially a specialized wrapper around the `inla` function of the R package `INLA`. As such, all arguments that can be passed to `inla` can be passed to `uniSpace`.

```{r, warning = FALSE}
modelLogit <- uniSpace(MEGR ~ ., spdf = MEGR01,
                       explanaMesh = explana, family = "binomial",
                       link = "logit", 
                       control.compute = list(waic = TRUE))
```

## Studying the estimated parameters

Although one of the main interest of species distribution models is to estimate and predict the distribution of species, it is also relevant and important to study the estimated parameters to better understand the importance of the considered explanatory variable in structuring the distribution of the species. If we focus on the logistic model for the moment, we can study these parameters using the `summary` function
 
```{r}
summary(modelLogit)
```

## Species distribution map

To get a good idea of the quality of the map resulting from the model, in addition of plotting the average model, it can be valuable to also plot the standard deviation or a 95% confidence interval around the model. All of these maps can be constructed using `mapSpace`.

```{r}
# Mean
mapMean <- mapSpace(modelLogit,
                    dims = dim(mite.envRaster)[1:2],
                    type = "mean",
                    sp = spacePoly)
# Standard deviation
mapSd <- mapSpace(modelLogit,
                    dims = dim(mite.envRaster)[1:2],
                    type = "sd",
                    sp = spacePoly)
# Lower boundary of the 95% confidence interval
map.025 <- mapSpace(modelLogit,
                    dims = dim(mite.envRaster)[1:2],
                    type = "0.025quant",
                    sp = spacePoly)
# Upper boundary of the 95% confidence interval
map.975 <- mapSpace(modelLogit,
                    dims = dim(mite.envRaster)[1:2],
                    type = "0.975quant",
                    sp = spacePoly)
```

```{r,  fig.width = 6, fig.height=8}
# Colour to use for the maps
colo <- colorRampPalette(c("grey90", "steelblue4", 
                           "steelblue2", "steelblue1", 
                           "gold", "red1", "red4"))(200)

par(mfrow = c(2,2))
plot(mapMean, zlim = c(0, 1), col = colo,
     axes = FALSE, box = FALSE, main = "Mean")

plot(mapSd, zlim = c(0, 1), col = colo,
     axes = FALSE, box = FALSE, main = "Sd")

plot(map.025, zlim = c(0, 1), col = colo,
     axes = FALSE, box = FALSE, main = "2.5%")

plot(map.975, zlim = c(0, 1), col = colo,
     axes = FALSE, box = FALSE, main = "97.5")
```

By studying the mean distribution we can infer the distribution of the species in the study area, but by accounting for the standard deviation and the 95% confidence interval, we can also gain some knowledge about the area where we have high (or low) confidence in the prediction. 

# References